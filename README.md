# Features

Project in progress...

## Connection Struct

- The connection struct is a generic type which helps us read or write data to any socket connection. It is used by both client and server.
- The connection struct has a type parameter which can either be UNKNOWN_CONNECTION, CLIENT_CONNECTION, PEER_CONNECTION, or USER_CONNECTION.  
A new connection on the server is set to be UNKNOWN. It is later promoted to a PEER or a USER connection when the client sends the initial messages i.e. a user would send a NICK/USER pair and a server would send a PASS/SERVER to register.
- A connection can also store arbitary data for the client. This parameter is used to store a pointer to a corresponding Peer or User struct in a polymorphic way. It is initialised as soon as the connection type is determined.
- Message queues: A connection struct contains incoming and outgoing message queues as well as request and response buffers. This allows us to send or receive multiple messages to and fro a client at once. It is also used for storing chat messages from another client. The request and response buffer only store the data that is currently being read or transmitted. Since we may not send or receive all the data we use indices to keep track of where we are in the buffer.
- Note that the User and Peer struct have their own internal message queue. Initially messages are put in the main message queue, but after client registration, the messages are put in the internal message queues. This is done partly so we don't have to deal with Connection structs in the request handlers functions and have to cast the data to the right type.

## Server

### Data structures

- A hashtable `connections` is used to map sockets to connection structs for each connection, such as a client or peer.
- A hashtable `nick_to_user_map` to map a nick string to a user struct for a user. The users get a random nick in the beginning. As they update their nicks, the entry in the hashmap for that user is also updated. This map is useful to check which nicks are available and also access the User data when we are to deliver a message to some nick.
- A hashtable `name_to_channel_map` to map each channel name to a channel struct. Each server has their own copy of the channel. Since different users are connected to different servers, a channel message must be propogated to the entire network in order to reach all channel members. But a single server does not know all the clients in the channel.
- A hashtable `name_to_peer_map` is used to map the name of a peer server to a Peer struct. When a server-to-server connection is established the remote server becomes a peer for the current server. The server which initiates the connection is known as the ACTIVE_SERVER and the server which accepts the connections is known as PASSIVE_SERVER. The entry is added after registration as the peer name is not known before the SERVER message is received. The entry is removed when a server quits or disconnects and a SQUIT message is generated by the server that realised this event.
- A hashtable `nick_to_serv_name_map` is used to determine which users are connected to each server. This map is updated when a peer advertises a new user connection or relays the message from another server. This map helps keep track of all the users on the network at each server. The entries are removed when a user disconnects and a server sends a KILL request for that user.

### Summary

The server is implemented in an event-driven manner with the core being single-threaded and polling based. The server also uses non blocking IO on all connections as it has to process many requests at once.  The server uses buffers and message queues for communication as well as the Connection struct and the data structures mentioned previously. The message queue allows the server to prepare messages to be sent to a client before the client is ready to receive them.

The servers use a config file to configure the servers. Only servers specified in the file are allowed to participate in the network. This is recommended by the RFC. The config file contains the name of the server, the IP address, port number and password. The password is used for server-server registration. The port is the port that the server listens for connections. We can simply edit this file to add / remove servers. It behaves like a small database.

The client is implemented as a multi-threaded application so that it can communicate with the user on stdin as well as the server over a socket. The client also uses the connection struct and a similar queueing strategy. The client message queues are synchronised by mutex locks so messages can be sent from various threads. Most commands read from stdin are sent verbatim to the server, aside from adding a CRLF delimiter. This works out well because IRC is a text-based protocol. The client can accept special commands that are prefixed with a '/'. These commands allow us faster registration. We can use the client as a user or another server (for testing). For users, the client can recognise a text file that contains the username, realname and nick for that user. This allows the user to login with `/client filename`. For server mode, we can run a similar command such as `/register servername`. Here servername refers to the name in the config file.

## Logic

The main logic is that the epoll listens for Read/Write events on all the available client sock_to_user_map as well as the server listening socket. If the event is on the listening socket, that implies the server can connect to new clients and initialise their user data. This is done through the `Server_process_request()` function.
In the case the event is on a client socket, I handle three cases: read, write and error. On error, I disconnect the client. On write, we send any pending messages from that user's message queue. Lastly, on read, we receive any data and parse the message if it is complete. Otherwise, we store the bytes in the user's buffer for later.

There are various functions to handle the commands in the form of `Server_handle_XXXX()`.
These functions use the predefined message reply strings in `reply.h` and substitute the reply parameters such as user's nick.
The message parser in `message.h` is used to parse message details safely.

The server currently supports the following commands from the client: MOTD, NICK, USER, PING, QUIT.

## QUIT

The QUIT command is used by a client to indicate their wish to leave the server.
All data associated with this user is freed and socket is closed.
An ERROR reply is sent before closing the socket to allow the reader thread at the client to quit gracefully.
This is done through a 'quit' flag in the user data that is set to true when the QUIT request comes.
When the final message to the client is sent and if a quit flag is seen, the server knows to close that connection at that point.

## MOTD

This command sends a Message of the Day to the requesting user.
It looks up the current day's message from a file (motd.txt) that contains a list of quotes.
This file was downloaded using the `zenquotes.io` API using the script in `download_quotes.py`.
This list can be updated by repeating this script.
The server simply gets the line that is at position `day_of_year % total_lines`, where `total_lines < 365`.
The filename can be changed at any time as the server has a string to store the filename.

## NICK/USER: User Registration

- User can register with NICK and USER commands
- NICK can be used to update nick at any time
- Server keeps track of all the nicks that have been used by username_to_user_map
- User may skip NICK to reuse previous NICK if there is one
- USER can only be used once at the start to set username and realname.
- username is private to the user, it is the main identification source
- Users can use NICKs to send messages to another user
- User can use any NICK that is owned by a user

The code for registering is found in `register.c`.

## PRIVMSG

- This command is only enabled after registration for both sender and receiver.
- User can send message to another user using their nick.
- Server can accept any nick that user has owned as a valid target.
- Server searches the userame to nicks map to find the username of the target user.
- The server can look up the user's data through their username and check if they are online or not.
- The server will not send the message to a user that is offline.

## Client

The client implements a thread-based model with two threads:

### Main thread

- It is the duty of the main thread to read user input from stdin.
- This thread blocks on the getline() instruction.
- If the input is a valid IRC command, the string will be terminated by CRLF appropriately.
- If the input is a special command starting with a /, the client will generate the corresponding command.
- The irc command is added to the outbox queue to send to the server.
- The main thread quits when the user enters the QUIT or SQUIT command.

### Worker thread

- This thread polls the server socket for read/write events.
- It displays the messages read from the server to stdout.
- It writes the messages from the queue to the server.
- This thread quits when the server sends a ERROR message.

The process for exiting all threads works as follows: The user types in the QUIT command.
The main thread recognises that it is time to quit and after adding this last message to the queue, will quit.
The worked thread will send this message but wait for the response. The server will reply to a QUIT with a ERROR message.
When the worker thread receives a ERROR message it will quit. The ERROR message is also sent in case of errors such as incorrect password.

## Establishing Server-Server connection

## Establishing Client-Server connection

## Disconnect a server or client

## Relay messages

## Special Commands

The following commands have been designed for demonstration and are not part of the specification.

The following command is asynchronous in nature, i.e. they involve communicating with the entire network to create the full responsne.

Edge cases:

Command: TEST_LIST_SERVER
Replies:

- 901 RPL_TEST_LIST_SERVER_START
- 902 RPL_TEST_LIST_SERVER
- 903 RPL_TEST_LIST_SERVER_END

Algorithm:

- User requests origin server to list all servers on the network.
- server adds user to map `test_list_server_map` and initialises a struct with the following members:
  - a reference to the connection struct to send messages
  - a set containing all the peers of this server
    - this set inidicates which peers still need to send a reply
- we send the original client all the reply messages for the original server first.
- now we request the peers of the original server to also send a list reply for the same request.
- we can continue processing other commands from the user while waiting for replies for the TEST_LIST_SERVER request.
- The reply is sent in a multipart message, so that when one of the peers recursively sends back a reply for servers behind their connection, we relay this information to the original client in turn.
- In particular, when one of the peers sends a RPL_TEST_LIST_SERVER to the origin server, we add this response to the original client's message queue.
- when one of the peers sends a RPL_TEST_LIST_SERVER_END to the origin server, this indicates that the peer has finished listing all the servers behind their server.
So this peer is removed from the set.
- When the set is empty, we have finished listing all servers so we can send a RPL_TEST_LIST_SERVER_END to the original client and remove their entry from the map.
- If during this period a new server joins, we simply ignore them from the response.
- If during this period the user sends another list request, we do not acknowledge it.

## How to keep consistent state across the network

- Event of server disconnect:
  - Broadcast a SQUIT message for each server behind that connection
  - Broadcast a QUIT for each client behind that connection
- Event of new server connection:
  - Both servers share the names of their peers with each other
  - Both servers share the NICKs of their clients with each other
  - Both servers share their channels with each other
- Event of client disconnect:
  - Broadcast a QUIT for that client to all peers

## Routing messages

Observe that the IRC network is a spanning tree structure, so it has no cycles. We use a BFS like algorithm to route messages from one server to another.

Suppose we have three clients alice and bob and cat.
There are three servers A,B and C.
There are the following edges in the network graph: A <-> B and A <-> C.
Suppose alice is connected to A, bob is connected to B and cat is connected to C.

Suppose alice wants to send a message "hello" to cat.

The following actions will take place:

- alice will send a message `PRIVMSG cat :hello` to server A
- server A will check if cat is a client known to it.
- Since server A knows C, it will check if cat is a client on the server A.
- Since cat is not a client on server A, server A will relay this message to each of its peers in the `name_to_peer_map`, namely server B and server C.
- server A will add B and C to a visited set because we may have multiple entries in the hashtable that map to the same peer.
This is because there can be multiple servers behind one connection and each server keeps track of all other servers in its hashtable.
- server B and server C recursively do the same thing.
- server B knows the client cat and cat does not live on server B. At the point server B can ignore the message because
server B's only peer is A and a server should never relay a message back to the sender, otherwise there would be an infinite loop.
- server C will finally see that cat lives on that server. server C will not relay this message any further to avoid wasting bandwidth.
- server C will add this message to cat's message queue. When cat is ready to receive messages, this server will write this message over the socket to cat's client program.
- the client program will display this message to cat.

As you can see, all messages are propogated down the network until they reach the destination or an edge. The messages make their way to the destination through a series of relays on intermediate servers. This strategy would work on any number of servers as long as they follow the main rule that the network is a spanning tree.

Note: It is possible to optimise the path. There are optional features in the protocol to allow the servers to gain more information about the network. For example, we can attach a "hop count" parameter to some messages so that servers can know the distance between two nodes on the network. With more information, the server can pre compute the shortest path to the client and only relay messages to a few peers.
